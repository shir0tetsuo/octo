<!DOCTYPE html>
<html lang="en">
    <head>
        
        <title>Map</title>
        <!-- https://remixicon.com/ -->
        <link
            href="https://cdn.jsdelivr.net/npm/remixicon@4.7.0/fonts/remixicon.css"
            rel="stylesheet"
        />
        <!-- favicon block -->
        <link rel="icon" type="image/png" sizes="512x512" href="favicon/android-chrome-512x512.png">
        <link rel="icon" type="image/png" sizes="192x192" href="favicon/android-chrome-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
        <link rel="apple-touch-icon" href="favicon/apple-touch-icon.png">
        <link rel="alternate icon" href="favicon/favicon.ico">
        <!-- jquery block -->
        <script src="js/jquery-3.7.1.js"></script>

        <link rel="stylesheet" href="css/common.css">
        <link rel="stylesheet" href="css/map.css">
        <link rel="stylesheet" href="css/map_elements.css">

        <!-- Bots No Index No Follow -->
        <meta name="ROBOTS" content="NOINDEX,NOFOLLOW">

        <!-- For mobile support -->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <meta name="theme-color" content="#3da79a">
        <meta property="og:site_name" content="Octo Application">
        <meta property="og:image" content="./img/about-bg.gif">
        <meta data-react-helmet="true" property="og:description" content="Lightweight repository project interacts with API Servers for a simple Data Library">    

    </head>
    <body>
        <div class="topnavigator">
            <div class="topleftbox">
                <div class="floating-right" id="loading"><div class="bouncing-loader"><div></div><div></div><div></div></div></div>
                
                <!-- Common -->
                <div class="topnavleft"><a href="index.html"><i class="ri-base-station-fill"></i> status</a></div>
                <div class="topnavleft"><a href="login.html?redirect=map.html" class="phasedBlue" id="user-login-nav"><i class="ri-passport-line"></i> login</a></div>
                <!-- Map View Navigation -->
                <div class="topnavleft"><a href="#" class="phasedYel"><i class="ri-treasure-map-line"></i> area</a></div>
                <div class="topnavleft"><a href="#" class="phasedYel" id="x_minus"><i class="ri-arrow-left-circle-line"></i> X-</a></div>
                <div class="topnavleft"><a href="#" class="phasedYel" id="x_plus"><i class="ri-arrow-right-circle-line"></i> X+</a></div>
                <div class="topnavleft"><a href="#" class="phasedYel" id="y_minus"><i class="ri-arrow-down-circle-line"></i> Y-</a></div>
                <div class="topnavleft"><a href="#" class="phasedYel" id="y_plus"><i class="ri-arrow-up-circle-line"></i> Y+</a></div>
                <div class="topnavleft"><a href="#" class="phased"><i class="ri-compass-discover-line"></i> search</a></div> <!-- Currently Unused -->

                <div class="skeleton-image" id="skeletonloading"></div>
            </div>
        </div>

        <div class="container" id="grid">
            <!-- Content -->
        </div>


        <script type="text/javascript">

            // Cell Building

            const grid = document.getElementById("grid");

            function applyChannelAnimation(pad, bar) {
                if (!bar || typeof bar !== "object") return;

                const channels = Object.values(bar); // channel_0 → channel_7

                channels.forEach((c, i) => {
                    pad.style.setProperty(`--c${i}`, c);
                });

                // First 4 drive the background animation
                for (let i = 0; i < 4; i++) {
                    pad.style.setProperty(`--ch-${i}`, channels[i % channels.length]);
                }
            }

            /* Navigate to Entity : Build the URL component, execute on click */
            function NavigateToEntity(entity) {
                const xyzi = encodeURIComponent(`${entity.positionX},${entity.positionY},${entity.positionZ},${entity.iter}`);
                function handleSuccess(response) {
                    console.log('Server responds with data.')
                    console.log(response)
                    if ( !response?.valid_key) { safeExit(); };
                }
                redirect = encodeURIComponent(window.location.pathname + window.location.search);
                window.location.href = `entity.html?xyzi=`+xyzi+`&redirect=${redirect}`;
            }

            function buildCell(entity) {
                const cell = document.createElement("div");
                cell.className = "cell";
                cell.dataset.state = entity.state ?? 0;

                const pad = document.createElement("div");
                pad.className = "cell-pad";

                // ✅ correct channel handling
                applyChannelAnimation(pad, entity.aesthetics?.bar);

                const seed = parseInt(entity.uuid?.replace(/-/g, "").slice(0, 6), 16) || 0;
                pad.style.animationDelay = `${-(seed % 1200) / 100}s`;

                const inner = document.createElement("div");
                inner.className = "cell-inner";

                const top = document.createElement("div");
                top.className = "glyph-top";

                const bottom = document.createElement("div");
                bottom.className = "glyph-bottom";

                const glyphs = Object.values(entity.aesthetics?.glyphs || {});
                glyphs.slice(0, 8).forEach((g, i) => {
                    const d = document.createElement("div");
                    d.className = "glyph-slot";
                    if (i == 7) {
                        d.style=("cursor: pointer");
                        d.className = "glyph-slot NavElement"
                        d.onclick = () => NavigateToEntity(entity);
                    }
                    d.textContent = g;

                    d.style.setProperty("--glyph-ch", i);
                    d.style.animationDelay = `${i * 0.2}s`;

                    if (i < 4) top.appendChild(d);
                    else bottom.appendChild(d);
                });

                const center = document.createElement("div");
                center.className = "center extrusionbase";

                const uuid = document.createElement("div");
                uuid.className = "uuid";
                uuid.textContent = `${entity.uuid.slice(0, 8)} #${entity.iter ?? 0}`;

                const owner = document.createElement("div");
                owner.className = "owner";
                owner.textContent = entity.owner ?? "00000000";

                // extrusion tooltip with hidden timestamp
                const extrusion = document.createElement("div");
                extrusion.className = "extrude";

                // Hidden timestamp value in a data attribute
                const timestamp = entity.timestamp ?? 0; // float/int
                extrusion.dataset.ts = timestamp;

                const display = document.createElement("div");
                //display.href = "#";
                display.textContent = "--:--:--:--";
                extrusion.appendChild(display);

                // Function to update the display
                function updateExtrusion() {
                    const ts = parseFloat(extrusion.dataset.ts) * 1000;
                    if (ts === 0) {
                        display.innerHTML = "--:--:--:--"
                        //display.textContent = "--:--:--:--";
                    } else {
                        let diff = (Date.now() - ts) / 1000; // seconds
                        const days = Math.floor(diff / 86400);
                        const hours = Math.floor((diff % 86400) / 3600);
                        const minutes = Math.floor((diff % 3600) / 60);
                        const seconds = Math.floor(diff % 60);
                        display.innerHTML = `${days}d${hours}h${minutes}m${seconds}s`;
                    }
                    requestAnimationFrame(updateExtrusion);
                }

                const channels = Object.values(entity.aesthetics?.bar);
                const CellBar = document.createElement("div");
                CellBar.className = "cell-bar";

                channels.forEach((c, i) => {
                    const next = channels[(i + 1) % channels.length];
                    const BarEl = document.createElement("div");
                    BarEl.style.setProperty(`--xch0`, c)
                    BarEl.style.setProperty(`--xch1`, next)
                    BarEl.className = "bar-el";
                    CellBar.append(BarEl)
                })
                extrusion.append(CellBar);

                requestAnimationFrame(updateExtrusion);

                center.append(uuid, owner, extrusion);
                inner.append(top, center, bottom);
                pad.append(inner);
                cell.append(pad);

                return cell;
            }


            function populateGrid(entityRows) {
                grid.innerHTML = "";

                for (let y = 0; y < 8; y++) {
                    const row = entityRows[y];
                    if (!row) continue;

                    for (let x = 0; x < 8; x++) {
                        const entity = row[x];
                        grid.appendChild(buildCell(entity));
                    }
                }
            }


            // Factory Functions

            function RenderFactory(url, x, y, z, apikey=null) {
                return $.ajax({
                    type: "POST",
                    url: url,
                    timeout: 1500,
                    contentType: "application/json",
                    dataType: "json",
                    headers: apikey ? { "X-API-Key": apikey } : {},
                    data: JSON.stringify({ 'x_axis': x, 'y_axis': y, 'z_axis': z, 'time_axis': null })
                })
            }

            function positiveNumber(params, param, fallback) {
                const v = Number(params.get(param));
                return Number.isFinite(v) && v > 0 ? v : fallback;
            }

            function nonNegativeNumber(params, param, fallback) {
                const v = Number(params.get(param));
                return Number.isFinite(v) && v >= 0 ? v : fallback;
            }

            function normalizeURL(x, y, z) {
                const params = new URLSearchParams();

                params.set("x", x);
                params.set("y", y);
                params.set("z", z);

                const newURL = `${window.location.pathname}?${params.toString()}`;

                window.history.replaceState({}, "", newURL);
            }

            function buildURL(x, y, z) {
                const params = new URLSearchParams({
                    x: x,
                    y: y,
                    z: z
                });

                return `${window.location.pathname}?${params.toString()}`;
            }

            function updateNavLinks(x, y, z) {
                $("#x_plus").attr("href", buildURL(x + 1, y, z));
                $("#x_minus").attr("href", buildURL(Math.max(0, x - 1), y, z));

                $("#y_plus").attr("href", buildURL(x, y + 1, z));
                $("#y_minus").attr("href", buildURL(x, Math.max(0, y - 1), z));
            }

            function getApiKeyFromCookie() {
                const match = document.cookie.match(/(?:^|; )X-API-Key=([^;]*)/);
                return match ? decodeURIComponent(match[1]) : null;
            }

            function toggleLoadingBar(force, loadingID='loading') {
                const loading = document.getElementById(loadingID);

                if (force !== undefined) {
                    // If force is provided, explicitly set display
                    loading.style.display = force ? 'block' : 'none';
                } else {
                    // Otherwise, toggle
                    loading.style.display = (loading.style.display === 'none') ? 'block' : 'none';
                }
            }

            function launch_error_toast(error_text) {
                var t = document.getElementById("error_toast")
                var d = document.getElementById("error_desc")
                t.className = "show";
                d.innerText = error_text;
                setTimeout(function(){ t.className = t.className.replace("show", ""); }, 5000);
            }

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function illuminate(res) {
                b = shuffle(res.banner);
                b.forEach((value, i) => {
                    document.documentElement.style.setProperty(`--banner-channel-${i}`, value);
                });
            }

            function ChangeUserNav(res) {
                nav = document.getElementById('user-login-nav');
                if (res.user_context.decryption_success) {
                    nav.href = 'user.html'; // This will point to the user page
                    nav.innerHTML = '<i class="ri-passport-fill"></i> ' + String(res.user_context.ID).split('-')[0];
                } else {
                    nav.href = `login.html?redirect=${encodeURIComponent(window.location.pathname + window.location.search)}`;
                }
            }

            document.addEventListener("DOMContentLoaded", function () {

                // Get params from location
                const params = new URLSearchParams(window.location.search);

                const xpos = Math.floor(nonNegativeNumber(params, 'x', 0));
                const ypos = Math.floor(nonNegativeNumber(params, 'y', 0));
                // Enforce [0,1,2,3,4,5,6,7] # 8 Zones
                const zone = Math.min(7, Math.max(0, Math.floor(nonNegativeNumber(params, 'z', 0))));

                const apiKey = getApiKeyFromCookie();

                console.log(xpos, ypos, zone, apiKey)

                // normalize & update navigation
                normalizeURL(xpos, ypos, zone);
                updateNavLinks(xpos, ypos, zone);

                // Load Data from Server
                RenderFactory("https://octo.shadowsword.ca/api/render", xpos, ypos, zone, apiKey)
                .done(function (res) {
                    console.log(res)
                    if (res.message == "OK") {
                        illuminate(res)
                        ChangeUserNav(res)
                        populateGrid(res.entities)
                        toggleLoadingBar(false)
                        toggleLoadingBar(false, 'skeletonloading')
                    }
                    
                })
                .fail(function () {
                    // fallback
                    console.warn("Couldn't establish DNS connection, falling back to localhost.")
                    RenderFactory("http://localhost:9300/api/render", xpos, ypos, zone, apiKey)
                    .done(function (res) {
                        console.log(res)
                        if (res.message == "OK") {
                            illuminate(res)
                            ChangeUserNav(res)
                            populateGrid(res.entities)
                            toggleLoadingBar(false)
                            toggleLoadingBar(false, 'skeletonloading')
                        }
                        
                    })
                    .fail(function () {
                        // Cannot load page, display Error Message
                        console.warn('Cannot establish server connection.')
                        launch_error_toast('Cannot establish server connection.')
                        toggleLoadingBar(false)
                        toggleLoadingBar(false, 'skeletonloading')
                    });
                });

            });


        </script>

        <div id="error_toast"><div id="icon"><i class="ri-signal-wifi-error-line"></i></div><div id="error_desc"></div></div>
    </body>
</html>